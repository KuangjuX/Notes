# Instruction Level Parallelism(ILP) and Its Exploitation

## Concepts and Challenges

有两个大的主题用于开发 ILP：

- 依赖于硬件去动态开发并行
- 依赖于软件在编译时静态发现并行

流水线的 CPI（cycles per instruction）的值是基础 CPI 和所有产生暂停的时间的和：

Pipeline CPI = Ideal pipeline CPI + Structural stalls + Data hazard stalls + Control stalls

在本章中我们主要介绍减少 ideal pipeline CPI 的技术，这会提升解决冒险技术的重要性。

### What Is Instruction-Level Parallelism?

最简单和最普通的去提升 ILP 的方式是在循环中实现并行，这种类型的并行叫做 `loop level parallesim`，接下来是个简单的例子：

```
for(i = 0; i <= 999; i = i+1)
	x[i] = x[i] + y[i];
```

指令集并行的技术可以通过在编译器中静态地进行展开或者在在硬件上动态执行。一个实现 `loop level parallesim` 的方法是在向量处理器或者 GPU 上面使用 SIMD。SIMD 通过并行处理少量到中等的数据项来实现数据并行。向量指令通过使用并行处理单元和深流水线来并行处理许多数据项。

### Data Dependences and Hazards

#### Data Dependeces

- 指令 i 提供的结果被指令 j 使用
- 指令 j 数据依赖于指令 k，并且指令 k 数据依赖于指令 i

一个关于数据依赖的例子：

```assembly
Loop: fld f0,0(x1) //f0=array element
	  fadd.d f4,f0,f2 //add scalar in f2
	  fsd f4,0(x1) //store result
	  addi x1,x1," 8 //decrement pointer 8 bytes
	  bne x1,x2,Loop //branch x16¼x2
```

数据依赖的两条指令必须按顺序执行不能同时执行否则会造成流水线互锁(pipeline interlocks)，流水线互锁指的是硬件去探测冒险和暂停直到冒险被清除。在一个没有 pipeline interlock 机制的处理器上只能依靠编译器调度来解决。

可以通过两种方法解决数据依赖：

- 维护依赖但是避免产生数据冒险
- 通过转换代码来消除依赖，这既可以通过编译器也可以通过硬件

数据依赖可能会发生在两个地方

- 寄存器堆，发生在这里比较好解决，因为在指令中的寄存器名字是固定的
- 内存中，这里比较难以探测，因为很可能两个地址是一样的但是看起来完全不同

#### Name Dependences

Name Dependences 指的是当两条指令使用同样的寄存器或者内存地址，但是与该名称相关的指令之间没有数据流。有两种 name dependeces，我们假设指令 i 发生在指令 j 的前面的时候来举例说明：

- antidependence: j 指令写 i 指令要读的内存地址或者是寄存器，这里必须保证 i 指令读到的是对的
- output dependence: i 和 j 指令同时写一块内存地址或者寄存器，必须保证最后的值是 j 指令写的

重命名可能是对于寄存器操作比较容易的做法，这种做法叫做寄存器重命名(register renaming)。寄存器重命名即可以被编译器来做也可以被硬件来做。

#### Data Hazards

有三种数据冒险的类型：

- RAW(read after write)：j 尝试去读取值当 i 指令写完成之前，所以 j 指令拿到了旧的值
- WAW(write after write)：j 尝试写一个值在 i 已经写完之前，最终被 i 指令写而不是被 j 指令写
- WAR(write after read)：j 尝试写在被 i 读取之前

#### Control Dependences

一个最简单的 Control Dependences:

```
if p1 {
	S1;
};
if p2 {
	S2;
}
```

- 依赖于控制的指令不能在分支之前移动分支，使其执行不再受分支控制。例如，我们不能从 if 语句的 then 部分获取指令并移动它在 if 语句之前。
- 不依赖于控制的指令不能移到后面分支，使其执行由分支控制。例如，我们不能在 if 语句之前取一个语句并将其移动到 then 部分。

一个控制依赖的例子：

```
	add x2,x3,x4
	beq x2,x0,L1
	ld x1,0(x2)
L1:
```

如果我们不注意控制依赖并将 `ld` 移到 `beq` 指令之前，加载指令可能会造成内存保护异常。

## Basic Compiler Techniques for Exposing ILP

## Reducing Branch Costs With Advanced Branch Prediction

## Overcoming Data Hazards With Dynamic Scheduling

一个简单的静态调度流水线获取一个指令然后发射它，除非在流水线中存在数据依赖的指令，并且不可以通过 bypassing/forwarding 等方法来消除。如果一个数据依赖不能被隐藏，然后数据冒险将会暂停流水线直到清除依赖关系。我们将探索一个动态调度算法从而可以减少暂停流水线。

### Dynamic Scheduling: The Idea

简单流水线的一个主要的限制是它们使用按顺序的指令发射执行，那么如果一个指令在流水线中暂停，之后的指令都得不到执行。如果一个指令 j 依赖于一个多周期的指令 i，那么在 j 之后的指令都必须等到 i 执行完之后才可以发射：

```
fdiv.d f0,f2,f4
fadd.d f10,f0,f8
fsub.d f12,f8,f14
```

在传统五级流水线中，结构和数据冒险都需要在译码阶段进行检查，如果一条指令执行没有冒险的话，当所有数据冒险解决后进行发射。

如果我们想去执行 `fsub.d` 这个指令我们必须将发射分成两部分：首先检查结构冒险和等待不存在数据冒险。因此我们仍然使用顺序发射，但是我们想要去执行指令一旦这条指令的操作数是可获得的，这样一种做法是乱序执行。乱序执行引入了 WAR 和 WAW 冒险，这些是不存在于传统五级流水线的：

```
fdiv.d f0,f2,f4
fmul.d f6,f0,f8
fadd.d f0,f10,f14
```

在 `fmul.d` 和 `fadd.d` 这两条指令之间有一个 antidependnce，如果 `fadd.d` 在 `fmul.d` 之前执行完的话，它将会造成错误，生成 WAR 冒险。相似地，为了避免 output dependence，例如在 `fdiv.d` 和 `fadd.d` 之间，WAW 冒险也必须处理。正如我们之后看到的，我们可以使用寄存器重命名消除冒险。

乱序执行也在处理异常时制造了困难。乱序执行必须保留那些使用严格的顺序执行出现的异常处理。动态调度的处理器通过延迟相关异常的通知来保持异常行为，直到处理器知道该指令应该是下一个完成的指令。尽管异常行为必须被保存，但是动态调度处理器可能会产生不精确的异常。不精确异常指的是乱序执行处理器发生的异常时的状态与顺序执行时的处理器状态不同，不精确异常可能由以下两方面造成：

- 流水线可能已经完成了发生异常之后的指令
- 流水线可能还没完成在发生异常之前的一些指令

不精确异常将会在异常后重新开始执行变得很困难，关于如何执行精确异常我们将会在之后提到。现在我们为了可以支持乱序执行，我们将五级流水线的译码阶段切分成两阶段：

- Issus: 译码，检查结构冒险
- Read operands: 等待直到没有数据冒险，然后读取操作数

## Dynamic Scheduling: Examples and the Algorithm

