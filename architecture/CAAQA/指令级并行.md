# Instruction Level Parallelism(ILP) and Its Exploitation

## Concepts and Challenges

有两个大的主题用于开发 ILP：

- 依赖于硬件去动态开发并行
- 依赖于软件在编译时静态发现并行

流水线的 CPI（cycles per instruction）的值是基础 CPI 和所有产生暂停的时间的和：

Pipeline CPI = Ideal pipeline CPI + Structural stalls + Data hazard stalls + Control stalls

在本章中我们主要介绍减少 ideal pipeline CPI 的技术，这会提升解决冒险技术的重要性。

### What Is Instruction-Level Parallelism?

最简单和最普通的去提升 ILP 的方式是在循环中实现并行，这种类型的并行叫做 `loop level parallesim`，接下来是个简单的例子：

```
for(i = 0; i <= 999; i = i+1)
	x[i] = x[i] + y[i];
```

指令集并行的技术可以通过在编译器中静态地进行展开或者在在硬件上动态执行。一个实现 `loop level parallesim` 的方法是在向量处理器或者 GPU 上面使用 SIMD。SIMD 通过并行处理少量到中等的数据项来实现数据并行。向量指令通过使用并行处理单元和深流水线来并行处理许多数据项。

### Data Dependences and Hazards

#### Data Dependeces

- 指令 i 提供的结果被指令 j 使用
- 指令 j 数据依赖于指令 k，并且指令 k 数据依赖于指令 i

一个关于数据依赖的例子：

```assembly
Loop: fld f0,0(x1) //f0=array element
	  fadd.d f4,f0,f2 //add scalar in f2
	  fsd f4,0(x1) //store result
	  addi x1,x1," 8 //decrement pointer 8 bytes
	  bne x1,x2,Loop //branch x16¼x2
```

数据依赖的两条指令必须按顺序执行不能同时执行否则会造成流水线互锁(pipeline interlocks)，流水线互锁指的是硬件去探测冒险和暂停直到冒险被清除。在一个没有 pipeline interlock 机制的处理器上只能依靠编译器调度来解决。

可以通过两种方法解决数据依赖：

- 维护依赖但是避免产生数据冒险
- 通过转换代码来消除依赖，这既可以通过编译器也可以通过硬件

数据依赖可能会发生在两个地方

- 寄存器堆，发生在这里比较好解决，因为在指令中的寄存器名字是固定的
- 内存中，这里比较难以探测，因为很可能两个地址是一样的但是看起来完全不同

#### Name Dependences

Name Dependences 指的是当两条指令使用同样的寄存器或者内存地址，但是与该名称相关的指令之间没有数据流。有两种 name dependeces，我们假设指令 i 发生在指令 j 的前面的时候来举例说明：

- antidependence: j 指令写 i 指令要读的内存地址或者是寄存器，这里必须保证 i 指令读到的是对的
- output dependence: i 和 j 指令同时写一块内存地址或者寄存器，必须保证最后的值是 j 指令写的

重命名可能是对于寄存器操作比较容易的做法，这种做法叫做寄存器重命名(register renaming)。寄存器重命名即可以被编译器来做也可以被硬件来做。

#### Data Hazards

有三种数据冒险的类型：

- RAW(read after write)：j 尝试去读取值当 i 指令写完成之前，所以 j 指令拿到了旧的值
- WAW(write after write)：j 尝试写一个值在 i 已经写完之前，最终被 i 指令写而不是被 j 指令写
- WAR(write after read)：j 尝试写在被 i 读取之前

#### Control Dependences

一个最简单的 Control Dependences:

```
if p1 {
	S1;
};
if p2 {
	S2;
}
```

- 依赖于控制的指令不能在分支之前移动分支，使其执行不再受分支控制。例如，我们不能从 if 语句的 then 部分获取指令并移动它在 if 语句之前。
- 不依赖于控制的指令不能移到后面分支，使其执行由分支控制。例如，我们不能在 if 语句之前取一个语句并将其移动到 then 部分。

一个控制依赖的例子：

```
	add x2,x3,x4
	beq x2,x0,L1
	ld x1,0(x2)
L1:
```

如果我们不注意控制依赖并将 `ld` 移到 `beq` 指令之前，加载指令可能会造成内存保护异常。

## Basic Compiler Techniques for Exposing ILP

TODO

## Reducing Branch Costs With Advanced Branch Prediction

TODO

## Overcoming Data Hazards With Dynamic Scheduling

一个简单的静态调度流水线获取一个指令然后发射它，除非在流水线中存在数据依赖的指令，并且不可以通过 bypassing/forwarding 等方法来消除。如果一个数据依赖不能被隐藏，然后数据冒险将会暂停流水线直到清除依赖关系。我们将探索一个动态调度算法从而可以减少暂停流水线。

### Dynamic Scheduling: The Idea

简单流水线的一个主要的限制是它们使用按顺序的指令发射执行，那么如果一个指令在流水线中暂停，之后的指令都得不到执行。如果一个指令 j 依赖于一个多周期的指令 i，那么在 j 之后的指令都必须等到 i 执行完之后才可以发射：

```
fdiv.d f0,f2,f4
fadd.d f10,f0,f8
fsub.d f12,f8,f14
```

在传统五级流水线中，结构和数据冒险都需要在译码阶段进行检查，如果一条指令执行没有冒险的话，当所有数据冒险解决后进行发射。

如果我们想去执行 `fsub.d` 这个指令我们必须将发射分成两部分：首先检查结构冒险和等待不存在数据冒险。因此我们仍然使用顺序发射，但是我们想要去执行指令一旦这条指令的操作数是可获得的，这样一种做法是乱序执行。乱序执行引入了 WAR 和 WAW 冒险，这些是不存在于传统五级流水线的：

```
fdiv.d f0,f2,f4
fmul.d f6,f0,f8
fadd.d f0,f10,f14
```

在 `fmul.d` 和 `fadd.d` 这两条指令之间有一个 antidependnce，如果 `fadd.d` 在 `fmul.d` 之前执行完的话，它将会造成错误，生成 WAR 冒险。相似地，为了避免 output dependence，例如在 `fdiv.d` 和 `fadd.d` 之间，WAW 冒险也必须处理。正如我们之后看到的，我们可以使用寄存器重命名消除冒险。

乱序执行也在处理异常时制造了困难。乱序执行必须保留那些使用严格的顺序执行出现的异常处理。动态调度的处理器通过延迟相关异常的通知来保持异常行为，直到处理器知道该指令应该是下一个完成的指令。尽管异常行为必须被保存，但是动态调度处理器可能会产生不精确的异常。不精确异常指的是乱序执行处理器发生的异常时的状态与顺序执行时的处理器状态不同，不精确异常可能由以下两方面造成：

- 流水线可能已经完成了发生异常之后的指令
- 流水线可能还没完成在发生异常之前的一些指令

不精确异常将会在异常后重新开始执行变得很困难，关于如何执行精确异常我们将会在之后提到。现在我们为了可以支持乱序执行，我们将五级流水线的译码阶段切分成两阶段：

- Issus: 译码，检查结构冒险
- Read operands: 等待直到没有数据冒险，然后读取操作数

首先取指 (fetch) 阶段获取指令寄存器或者待等待的指令队列，然后指令进入到发射 (issue) 阶段，将指令从寄存器或者队列中发射出去。执行阶段随后开始读取操作数，就和五级流水中相同，执行阶段可能会占用多个周期，就和在五级流水中相同。我们的处理器允许多条指令同时执行，这要求处理器有多个功能单元(functioanal units)或者流水线功能单元(pipelien functional units)或者两者皆有，这两种在流水线上本质上是等价的。

动态调度流水线都会在发射阶段顺序通过，但是可能因为产生暂停或者互相绕过(bypass) ,从而乱序进入执行阶段 。计数板算法(Socreboarding) 是一项当有充足资源并且没有数据依赖的情况下允许指令乱序执行的算法。它以开发此功能的 CDC 6600 记分牌命名。 在这里，我们专注于一种更复杂的技术，称为 Tomasulo 算法。 主要区别在于 Tomasulo 的算法通过有效地动态重命名寄存器来处理反依赖和输出依赖。 此外，Tomasulo 的算法可以扩展到处理推测，这是一种通过预测分支结果、在预测的目标地址执行指令以及在预测错误时采取纠正措施来减少控制依赖影响的技术。 虽然记分板的使用可能足以支持更简单的处理器，但更复杂、更高性能的处理器使用推测。

### Dynamic Scheduling Using Tomasulo's Approach

Tomasulo 算法被 Robert Tomasulo 所提出，可跟踪操作和指令何时可用以最小化 RAW 冒险，并在硬件中引入寄存器重命名以最小化 WAW 和 WAR 冒险。 尽管在最近的处理器中这种方案有很多变体，但它们都依赖于两个关键原则：动态确定指令何时准备好执行以及重命名寄存器以避免不必要的危险。

只有在操作数可用时才执行指令，从而避免 RAW 危害，这正是更简单的记分板方法所提供的。由名称依赖性引起的 WAR 和 WAW 冒险可以通过寄存器重命名来消除。 寄存器重命名通过重命名所有目标寄存器来消除这些危险，包括那些对于较早指令的未决读取或写入的寄存器，因此无序写入不会影响任何依赖于操作数较早值的指令。

考虑如下例子：

```
fdiv.d f0,f2,f4
fadd.d f6,f0,f8
fsd f6,0(x1)
fsub.d f8,f10,f14
fmul.d f6,f10,f8
```

有两个 `antidependences`: 在 `fadd.d` 、 `fsub.d` 和 `fsd` 、`fmul.d` 指令之间。也有一个 `output dependences` : `fadd.d` 和 `fmul.d` 之间，前者是 WAR，后者是 WAW。同时还有几个真实的数据依赖（前面并不存在真实的数据依赖，只是乱序执行时有可能数据错了）。因此我们可以将寄存器重命名为:

```
fdiv.d f0,f2,f4
fadd.d S,f0,f8
fsd S,0(x1)
fsub.d T,f10,f14
fmul.d f6,f10,T
```

此外，f8 的任何后续使用都必须替换为寄存器 T。在此示例中，重命名过程可以由编译器静态完成。 查找代码后面的 f8 的任何使用需要复杂的编译器分析或硬件支持，因为在前面的代码段和 f8 的后续使用之间可能存在中间分支。 正如我们将看到的，Tomasulo 的算法可以处理跨分支的重命名。

下图展示了 Tomasulo 处理器的基础结构：

![](image/Tomasolu结构.png)

上图包含了浮点数单元和 load/store 单元，没有显示任何执行控制表。每个 reservation station 都持有一条已经被发射的指令，并等待功能单元执行。如果已经计算了该指令的操作数值，则它们也存储在该条目中； 否则，reservation station 条目保存将提供操作数值的保留站的名称。加载缓冲区和存储缓冲区保存来自和去往内存的数据或地址，其行为几乎与 reservation station 完全相同，因此我们仅在必要时区分它们。 浮点寄存器通过一对总线连接到功能单元，并通过一条总线连接到存储缓冲区。来自功能单元和内存的所有结果都在公共数据总线上发送，除了加载缓冲区外，该总线无处不在。 所有保留站都有标签字段，由流水线控制使用。

在我们正式介绍算法前我们先看看指令的 3 个流程，每个流程可能占用任意个周期：

- Issue: 从 FIFO 指令队列的头部获取下一条指令，以此维护指令的顺序性。如果有一个匹配的 reversation station 是空的，发射该指令和对应的操作数值（如果它们当前在寄存器中）到对应的 reversation station。如果没有空的 reservation station，则表明有结构相关冒险，然后该指令暂停直到 station 或者 buffer 被释放。如果操作数不在寄存器中，则跟踪会产生操作数的功能单元，在这一步进行寄存器重命名。

- Execute: 如果一个或多个操作数尚不可用，则在等待计算公共数据总线时监视它。 当一个操作数变得可用时，它被放置到任何等待它的保留站中。 当所有操作数都可用时，就可以在相应的功能单元执行操作。 通过延迟指令执行直到操作数可用，避免了 RAW 冒险。

    注意到可能几个指令在相同时钟周期内同样的功能单元同时准备好。尽管独立的功能单元可能在相同周期执行不同的指令，但是如果在相同的功能单元中有超过一条指令准备好了的话，该单元将从它们中选择一个。对于浮点数保留站，选择可能是任意的。但是对于加载和存储指令，情况则有些复杂。

    加载和存储指令需要两步骤执行：当基寄存器可获得时计算地址，然后该地址被放入加载或存储缓冲区中(load or store buffer)。当内存单元可获得时在 load buffer 中的加载指令立刻执行。存储指令存储在 store buffer 中直到值被送入内存单元。加载和存储指令保持程序顺序以防冒险。

    为了保持异常行为，在程序顺序中位于指令之前的分支完成之前，不允许任何指令启动执行。Speculation 提供了一种更灵活、更完整的方法来处理异常，因此我们将延迟进行此增强，并在稍后展示 Speculation 如何处理此问题。

- Write result：当结果可获得时，将其写到 CDB 总线中和从那些寄存器或者保留站中等待结果。存储指令缓存在 store buffer 中存储地址可获得并且值已经被存储了，然后将结果写入当内存单元是空闲的时候。

在 Tomasulo 算法和接下来要介绍的 speculation 中，结果被广播在 CDB 总线上，而 CDB 总线则由保留站所监测。

重要的是记住在 Tomasulo 算法中 tag 是指将产生结果的 buffer 或者 unit。当指令被发射到保留站中寄存器名字就被丢弃了。每个保留站有 7 个域：

- Op：对源操作数 S1 和 S2 执行的操作
- Qj, Qk：保留站将产生相关的源操作数；0 表示源操作数可以在 Vj 或者 Vk 中获得或者没有必要
- Vj, Vk：源操作数的值。对于每个操作，仅仅 V 域或者是 Q 域是有效的。对于加载指令，Vk 域被用于存放 offset 域
- A：用于保存用于加载或存储的内存地址计算的信息。 最初，指令的立即字段存储在这里； 地址计算完成后，有效地址就存放在这里。
- Busy：表明该保留站及其附属的功能单元已被占用

register file 有一个 field:

- Qi：包含其结果应存储到该寄存器中的操作的保留站的编号。 如果 Qi 的值为空白（或 0），则当前没有活动指令正在计算以该寄存器为目标的结果，这意味着该值只是寄存器内容。

加载和存储 buffer 都有一个域，A，放置第一步计算的 effective address 的结果。

## Dynamic Scheduling: Examples and the Algorithm



